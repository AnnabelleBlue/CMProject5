
require "drum_input.srp"

require "noteheader"
require "soloinput"
require "musicobj"
require "electronic"
require "algoobj"


////////////////////////
// Global definitions //
////////////////////////

soloObj = SoloistData()
musicObj = MusicData()
drumObj = DrumData()
algoObj = AlgoData()
electronicAlgorithm = ElectronicAlgorithm(musicObj, soloObj, drumObj)
algo_device = 1
param_device = 0


///////////////////////////////////////
//
//              Handlers
//
///////////////////////////////////////
vel = 80

// SOLOIST
def handle_8_push(path, isOn)
    display path, isOn
    
    // Sets note
    note = int(path[7])
    
    // If the note is double digits
    if len(path) == 9
        note = int(path[7] + path[8])
    
    note = note + 59
    
    // Turns note on or off
    if isOn > 0.5
        musicObj.note_on = note
    else
        musicObj.note_off = note
        
    // Adds note to algorithm input
    soloObj.addNote(Note(note, vel, 4))

    
// DRUM BEAT
def handle_2_multitoggle(path, isOn)
    x = int(path[17])
    y = int(path[15])
    offset = 0
    
    if len(path) == 19
        x = x * 10 + int(path[18])
  
    if int(y/2) == int((y-1)/2)
        offset = 16

    drumObj.drum_patterns[int((6-y)/2)][x - 1 + offset] = int(isOn)  
 
// ALGO SWITCHER / PARAMETER CONTROLLER
def handle_3_rotary(path, turn)
    var device = osc_server_reply()
    var index = int(path[9])
    
    if device == 1
        if index == 1
            algoObj.bass_vel = int(turn * 127)
        elif index == 1
            algoObj.treble_vel = int(turn * 127)
        display algoObj.bass_vel, algoObj.treble_vel
    
    display path, turn
    
toggles = [0,0,0]
// ALGO SWITCHER / PARAMETER CONTROLLER
def handle_3_toggle(path, isOn)
    var device = osc_server_reply()
    var flip = int(isOn)
    var index = int(path[9]) - 1
    
    if device == 0
        toggles[index] = flip
        
        instrument = musicObj.inst_list[toggles[0] + (toggles[1] * 2) + (toggles[2] * 4)]
        //vtsched.start_use()
        midi_out.program(0, instrument)
        //vtsched.finish_use()
        
        musicObj.instrument = instrument
        display "DEVICE 0", toggles, musicObj.instrument
    else
        if index == 0
            algoObj.arpeggio1On = flip
        elif index == 1
            algoObj.arpeggio2On = flip
        else 
            algoObj.electronicOn = flip
        display "DEVICE 1", path, isOn

    display path, isOn
        
// PARAMETER CONTROLLER
// Change Key
def handle_2_push(path, isOn)
    musicObj.root = 59 + int(path[7])
    display musicObj.root
    
// PARAMETER CONTROLLER
// Change tempo/velocity
def handle_3_fader(path, val)
    var index = int(path[8])
    
    if index == 1
        return
    if index == 2
        soloObj.velocity = int(127 * val)
    display path, val

// Change Major / Minor
// PARAMETER CONTROLLER
def handle_3_push(path, isOn)
    var index = int(path[7])
    if (index - 2) <= 0
        musicObj.isMaj = 0
    else
        musicObj.isMaj = 1
    display musicObj.isMaj

        
///////////////////////////////////////
//
//          Server Methods
//
///////////////////////////////////////
def add_server_methods()
    // SOLOIST
    for i = 1 to 25
        osc_server_method("/8/push" + str(i), "f", nil, 'handle_8_push')
        
    // DRUM BEAT
    for i = 1 to 7
        for j = 1 to 17
            osc_server_method("/2/multitoggle/" + str(i) + "/" + str(j), "f", nil, 'handle_2_multitoggle')

    // ALGO SWITCHER
    for i = 1 to 7
        osc_server_method("/3/rotary" + str(i), "f", nil, 'handle_3_rotary')

    for i = 1 to 6
        osc_server_method("/3/toggle" + str(i), "f", nil, 'handle_3_toggle')
        
    // PARAMETER CONTROLLER
    for i = 1 to 13
        osc_server_method("/2/push" + str(i), "f", nil, 'handle_2_push')
        
    for i = 1 to 6
        osc_server_method("/3/fader" + str(i), "f", nil, 'handle_3_fader')
    
    for i = 1 to 5
        osc_server_method("/3/push" + str(i), "f", nil, 'handle_3_push')
        
