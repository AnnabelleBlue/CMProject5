require "sched"
require "midi-io"
require "strparse.srp"

require "helpers"
require "handlers"
require "variables"



// Given a note, plays it. This schedules the eventual note_off as well.
// The notesList in musicObj is used to determine when notes are to be
// turned off.
def play_note(note)
    musicObj.addNote(note, midi_out)

def drumbeat(beat)    
    return
    
def algorithm()
   	melody_note = electronicAlgorithm.melody()
   	play_note(melody_note)
   	return

// Plays one beat of one instrument
def play_beat(beat) 
    drumbeat(beat)
    algorithm()
    musicObj.update(midi_out) // Increments the beat, stops notes,
    					// and other things.
    					// Should happen after the algo/drums play
    
    if beat == 31
        beat = 0
    
    // Schedule next event
    the_sched.cause(1, nil, 'play_beat', beat)
    
def timer_callback()
    rtsched.poll(time_get())
 
 
def start(rest ignore)
    vtsched.start_use()
    play_beat(0)
    vtsched.finish_use()
 
def schedule()
    midi_out.start(0)   // Starts up midi
    sched_init()        // Creates vtsched and rtsched
    rtsched.time_offset = time_get()
    vtsched.set_bpm(musicObj.tempo) // To match slider initial value
    osc_enabled = true

    vtsched.cause(1, nil, 'start')  // Starts playing
    
    sched_run()

def sched_poll():
    rtsched.poll(time_get())
    osc_server_poll()
    
def init()
    display "Device 1 Connect", osc_server_init("4401",t)
    add_server_methods()
    schedule()        
    
init()

